---@meta

--- Render options are set by explicit calls to `write` or by the return value
--- of the action function. They are accumulated in the `self.options` field of
--- the request object. Typically an action function does not generate the
--- response directly, but sets the options to be used by Lapis during the
--- rendering phase of the request which happens immediately after executing the
--- action.
---
--- For example, in the following action the `render` and `status` fields are
--- used to set the HTTP status response code, and specify a view by name to be
--- used to generate the response body.
---
--- ```lua
--- app:match("/", function(self)
---    return { render = "error", status = 404}
--- end)
--- ```
---
--- When rendering JSON make sure to use the `json` render option. It will
--- automatically set the correct content type and disable the layout:
---
--- ```lua
--- app:match("/hello", function(self)
---    return { json = { hello = "world" } }
--- end)
--- ```
---@class lapis.Request.options
---@field status? integer Sets HTTP status code of the response (eg. 200, 404, 500, …)
---@field render? boolean | string | lapis.Widget Renders a view to the output buffer during the rendering phase of the request. If the value is `true` then the name of the route is used as the view name. Otherwise the value must be a string or a view class. When a string is provided as the view name, it will be loaded as a module with `require` using the full module name `{app.views_prefix}.{view_name}`
---@field content_type? string Sets the `Content-type` header
---@field headers? table<string, string> A table of headers to add to the response
---@field json? any Renders the the JSON encoded value of the option. The `Content-Type` is set to `application/json` and the layout is disabled.
---@field layout? boolean | string | lapis.Widget Overrides the layout from the application default. Set to `false` to entirely disable the layout. Can either be a renderable object (eg. a Widget or etlua template), or a string. When a string is provided it is used as the view name, it will be loaded as a module with `require` using the full module name `{app.views_prefix}.{view_name}`
---@field redirect_to? string Sets status to 302 and uses the value of this option for the `Location` header. Both relative and absolute URLs can be used. (Combine with `status` to perform 301 redirect)
---@field skip_render? boolean Set to `true` to cause Lapis to skip it’s entire rendering phase (including content, status, headers, cookies, sessions, etc.). Use this if you manually write the request response in the action method (using low level `ngx.print`, `ngx.header` or equivalent). This can be used to implement streaming output, as opposed to Lapis' default buffered output.

--- When a request is processed, the action function is passed a `request object`
--- as its first argument. Because of Lua’s convention to call the first
--- argument `self`, we refer to the request object as `self` when in the
--- context of an action.
---@class lapis.Request
---@field route_name string The name of the route that was matched during routing, if available
---@field params table<string, string> A table containing all request parameters merged together, including query parameters and form-encoded parameters from the body of the request.
---@field GET table<string, string> A table containing only the query parameters included in the URL (eg. `?hello=world`). Note that this field is included for any request with URL query parameters, regardless of the HTTP verb used for the request.
---@field POST table<string, string> A table containing only the form encoded parameters included in the body of the request. Note that this field is included for any request with form data in the body, regardless of the HTTP verb.
---@field req any An object containing the internal request information generated by the underlying server processing the request. The full structure of this object is intentionally undocumented. Only resort to referencing it if you need server specific data not available elsewhere.
---@field res any An object used to used to generate the response for the client at the end of the request. The structure of this object is specific to the underlying server processing the request, and is intentionally undocumented.
---@field app lapis.Application The instance of the `lapis.Application` that is responding to requests. Note that a single instance is shared across many requests, but there may be multiple instances if there are multiple worker processes handling requests.
---@field cookies table<string, string> A proxy table that can be used to read any cookies that have been included with the request. New cookies can be stored for the response by setting them on this table. Only strings are supported as field names and values.
---@field session table A proxy table for reading and writing the dynamically created session object. A session object is a signed, json-encoded object that is transferred via cookies. Because it is signed, it’s safe to include data in it that you know the end user can not tamper with.
---@field options lapis.Request.options A table of options that will controls how the request is rendered. It is populated by calls to `write`, and also set by the return value of your action.
---@field buffer string[] The output buffer containing the fragments of text that will be written to the client after all processing is complete. Typically you'll not need to touch this manually. It is populated via the `write` method.
local Request = {}

--- Writes all of the arguments to the output buffer or options table. A
--- different action is done depending on the type of each argument.
---
--- * `string` — String is appended to output buffer
--- * `function` (or callable table) — Function is called with the output buffer,
--- result is recursively passed to `write`
--- * `table` - key/value pairs are assigned into `self.options`, all other
--- values are recursively passed to `write`
---@param ... string | fun(buff: string[]) | lapis.Request.options
function Request:write(...) end

--- Generates a URL for `name_or_obj`.
---
--- Note: `url_for` is a bit of a misnomer since it typically generates a path
--- to the requested page. If you want to get the entire URL you can combine
--- this function with `build_url`.
---
--- If `name_or_obj` is a string, then the route of that name is looked up and
--- filled using the values in params. If no route exists then an error is
--- thrown.
---
--- Given the following routes:
---
--- ```lua
--- app:match("index", "/", function()
---    -- ...
--- end)
---
--- app:match("user_data", "/data/:user_id/:data_field", function()
---    -- ...
--- end)
--- ```
---
--- URLs to the pages can be generated like this:
---
--- ```lua
--- returns: /
--- self:url_for("index")
---
--- -- returns: /data/123/height
--- self:url_for("user_data", { user_id = 123, data_field = "height"})
--- ```
---
--- If the third argument, `query_params`, is supplied, it will be converted
--- into query parameters and appended to the end of the generated URL. If the
--- route doesn’t take any parameters in the URL then `nil`, or empty object,
--- must be passed as the second argument:
---
--- ```lua
--- -- returns: /data/123/height?sort=asc
--- self:url_for("user_data", { user_id = 123, data_field = "height"}, { sort = "asc" })
---
--- -- returns: /?layout=new
--- self:url_for("index", nil, {layout = "new"})
--- ```
---
--- Any optional components of the route will only be included if all of the
--- enclosed parameters are provided. If the optional component does not have
--- any parameters then it will never be included.
---
--- Given the following route:
---
--- ```lua
--- app:match("user_page", "/user/:username(/:page)(.:format)", function(self)
---    -- ...
--- end)
--- ```
---
--- The following URLs can be generated:
---
--- ```lua
--- -- returns: /user/sylviettee
--- self:url_for("user_page", { username = "sylviettee" })
---
--- -- returns: /user/sylviettee/projects
--- self:url_for("user_page", { username = "sylviettee", page = "projects" })
---
--- -- returns: /user/sylviettee.json
--- self:url_for("user_page", { username = "sylviettee", format = "json" })
---
--- -- returns: /user/sylviettee/code.json
--- self:url_for("user_page", { username = "sylviettee", page = "code", format = "json" })
--- ```
---
--- If a route contains a splat, the value can be provided via the parameter
--- named `splat`:
---
--- ```lua
--- app:match("browse", "/browse(/*)", function(self)
---    -- ...
--- end)
--- ```
---
--- ```lua
--- -- returns: /browse
--- self:url_for("browse")
---
--- -- returns: /browse/games/recent
--- self:url_for("browse", { splat = "games/recent" })
--- ```
---
--- ### Passing an object to `url_for`
---
--- If `name_or_obj` is a table, then the `url_params` method is called on that
--- table, and the return values are passed to `url_for`.
---
--- The `url_params` method takes as arguments the request object, followed by
--- anything else passed to url_for originally.
---
--- It’s common to implement `url_params` on models, giving them the ability to
--- define what page they represent. For example, consider a `Users` model that
--- defines a `url_params` method, which goes to the profile page of the user:
---
--- ```lua
--- local Users = Model:extend("users", {
---    url_params = function(self, req, ...)
---       return "user_profile", { id = self.id }, ...
---    end
--- })
--- ```
---
--- We can now just pass an instance of `Users` directly to `url_for` and the
--- path for the user_profile route is returned:
---
--- ```lua
--- local user = Users:find(100)
--- self:url_for(user)
--- -- could return: /user-profile/100
--- ```
---
--- You might notice we passed `...` through the `url_params` method to the
--- return value. This allows the third `query_params` argument to still
--- function:
---
--- ```lua
--- local user = Users:find(1)
--- self:url_for(user, { page = "likes" })
--- -- could return: /user-profile/100?page=likes
--- ```
---
--- ### Using the `url_key` method
---
--- The value of any parameter in `params` is a string then it is inserted into
--- the generated path as is. If the value is a table, then the `url_key` method
--- is called on it, and the return value is inserted into the path.
---
--- For example, consider a Users model which we've generated a `url_key` method
--- for:
---
--- ```lua
--- local Users = Model:extend("users", {
---    url_key = function(self, route_name)
---       return self.id
---    end
--- })
--- ```
---
--- If we wanted to generate a path to the user profile we might normally write
--- something like this:
---
--- ```lua
--- local user = Users:find(1)
--- self:url_for("user_profile", {id = user.id})
--- ```
---
--- The `url_key` method we've defined lets us pass the `User` object directly as
--- the id parameter and it will be converted to the `id`:
---
--- ```lua
--- local user = Users:find(1)
--- self:url_for("user_profile", {id = user})
--- ```
---
--- Note: The `url_key` method takes the name of the path as the first argument,
--- so we could change what we return based on which route is being handled.
---@param name_or_obj string | table
---@param params? table
---@param query_params? table
---@param ... table
---@return string
function Request:url_for(name_or_obj, params, query_params, ...) end

---@class lapis.Request.build_url_opts
---@field scheme string eg. `http`, `https`
---@field host string
---@field port integer If port matches the default for the scheme (eg. 80 for http) then it will be left off
---@field fragment string Part of the URL following the `#`. Must be string
---@field query string of the URL following the `?`. Must be string

--- Builds an absolute URL for the path. The current request’s URI is used to
--- build the URL.
---
--- For example, if we are running our server on `localhost:8080`:
---
--- ```lua
--- self:build_url() --> http://localhost:8080
--- self:build_url("hello") --> http://localhost:8080/hello
---
--- self:build_url("world", { host = "sylvia-is.gay", port = 2000 }) --> http://sylvia-is.gay:2000/world
--- ```
---@param path string
---@param options? lapis.Request.build_url_opts
---@return string
function Request:build_url(path, options) end

--- Loads a flow by `module_name` with the `flows_prefix` on the current request
--- object. If the flow with that name had been previously loaded, then the
--- existing flow instance is returned.
---@param module_name string
---@return any
function Request:flow(module_name) end

--- Returns a new function that implements the buffer writer interface for
--- rendering the contents of `fn` as an HTML scoped function. Suitable for
--- returning from an action.
---@param fn function
---@return lapis.Request.options
function Request:html(fn) end

--- This function returns `self`. This method is useful in scenarios where the
---- request object is being proxied, and you wish to get a direct access to the
--- instance of the request object for mutation. Examples include within flows
--- and within widgets where the request object is embedded into the helper
--- chain.
---@return self
function Request:get_request() end

return Request
